; The lexicon is a collection of terms.

INDEX
	HOST : index
	BREF : Welcome to my corner of the internet!

PROJECTS
	HOST : index
	BREF : Archive of selected works and ongoing projects.
	TYPE : img_portal

KNOWLEDGE
	HOST : index
	BREF : A personal knowledge database.
	TYPE : img_portal

INTERACTIVE
	HOST : projects
	CAPT : 
	TYPE : img_portal
	BREF : Things to play or play with.

DEVELOPMENT
	HOST : projects
	TYPE : img_portal
	BREF : Tools and whatnot.

DIRECTORY
	HOST : index
	TYPE : img_portal
	BREF : Lists of things.

JOURNAL
	HOST : index
	BREF : The journal tracks updates and progress on various projects and day to day events.
	BODY
		Use this link to subscribe to the journal feed via RSS: <a href="http://wastingmoves.com/links/rss.xml">http://wastingmoves.com/links/rss.xml</a>

ABOUT
	HOST : index
	BREF : What is all this?
	TYPE : img_portal
	BODY
		This {meta website} is my digital garden and personal assistant. It is an ever growing, changing, living document that functions as a repository for {projects} and a personal database for {knowledge knowledge}.

SIMPLE GB ASM
	HOST : development
	BREF : A collection of simple GB assembly examples
	BODY
		# Motivation
		There's no shortage of Game Boy assembly tutorials on the internet, but as knowledge of the system has evolved and expanded over the decades since its release many of the older tutorials contain either misleading or incorrect information. While demand for lengthy tutorials is strong, I've found sometimes people merely want a simple, self-contained example to examine and run.
		I've put together what are meant to be {https://github.com/tbsp/simple-gb-asm-examples simple examples} demonstrating commonly used hardware features of the Game Boy to serve this purpose. These aren't meant to replace {https://eldred.fr/gb-asm-tutorial/ more extensive tutorials}, but merely to supplement them or help those who would prefer something more bite-sized.

		# Additional Comments
		Even knowing I wanted to keep things simple I quickly got caught up and the vblank example includes some "fancy" sine table tricks to generate a neat spinning sprite effect. Hopefully it doesn't distract from demonstration of the vblank interrupt itself!

		# Moving Foward
		Much like other examples/tutorials on this subject, mine aren't particularly deep. I have a list of future examples I'd like to get to, including grid collision, scrolling, fixed-point movement, and more. Naturally they will have to wait for inspiration to strike when free time permits.

	LINKS
		simple-gb-asm-examples : https://github.com/tbsp/simple-gb-asm-examples
		gb-asm-tutorial : https://eldred.fr/gb-asm-tutorial/

SHOCK LOBSTER
	HOST : interactive
	BREF : A simple action game for Game Boy
	BODY
		# Overview
		{^img games/shock_lobster/title.png}
		Shock Lobster is an action game developed for the Game Boy as an entry to the {https://gbdev.io/gbcompo21.html Game Boy Competition 2021}.
		Gameplay centers around using a variety of skills to deal maximum damage while avoiding oncoming obstables, trying to reach the highest possible score before defeat.
		# Design & Development
		My motivation for the game was semi-complicated skill priority systems in MMORPG games. While using the skills isn't challenging (hold the D-pad and press a button), using them effectively to maximize output takes some practice.
		Development took place over 3 months during the competition, with a few minor fixes released after the competition deadline. Although I'd been involved in Game Boy development from 1997 to 2004, I'd only recently returned in early 2021 and found a renewed interest in the platform.
		Compared to my earlier Game Boy work I'm now using a modern makefile with recipes to streamline asset conversion, compression, table generation, and linking. I'm also leaving a lot more up to RGBDS to figure out, which saves a lot of time when trying to pack a game into 32 KiB (see below).

		# Visual/Gameplay Effect Analysis
		What follows is a look at a variety of the effects and gameplay of the game from a development perspective, in the context of working within the restrictions of the Game Boy hardware.
		When the screenshots presented here include more than 4 colors (or shades), the different palettes are used to indicate if the elements are drawn using the background (B&W), window (yellow), or hardware sprites (red). Use of the window in Game Boy games tends to be limited to top/bottom/right side HUDs, athough in many cases top/bottom HUDs will require disabling sprites via a scanline interrupt, at which point scroll registers and the active tilemap could easily be adjusted as well to merely use the background, so the use of the window isn't strickly necessary.
		Since Shock Lobster tries to use the window in more creative ways, colorizing it with a distinct palette can be useful for demonstration purposes.

		## Bootup Logo Effect
		After the Game Boy bootrom executes, the system hands over control with the Nintendo logo tiles in VRAM, and the logo tilemap loaded. It's up to the game to clear the logo, but sometimes games choose to play with a bit.
		To split the logo five ways I replaced the (R) symbol with a sprite, cleared the tile underneath, copied the right half of the logo tilemap to the second tilemap, enabled the window overlapping the right half of the logo, cleared the half of the logo left underneath, and then started animating things.
		{^img games/shock_lobster/boot_color1.png}
		I start out splitting the logo vertically, which by itself would only require adjusting the vertical scroll register, and then adjust the horizontal scroll and window horizontal position as well to introduce a horizontal split. The movements are all read from lookup tables in ROM.
		{^img games/shock_lobster/boot_color2.png}

		## Scanline Interrupts
		The Game Boy has what's called a programmable scanline interrupt. There are a few ways it can be setup, but the way we'll be using it fires the interrupt when the scanline (LY) matches the value in the LYC register.
		We'll be storing what I call a "raster table" in WRAM, which is comprised of sets of values representing:
		+ Horizontal scroll value (SCX)
		+ Window X position value (WX)
		+ LCD Controller value (LCDC)
		+ LY Compare (LYC) for the following entry
		When the interrupt fires we're at the start of the scanline, but we can't safely set all the registers we want to at that point. So we setup for the register writes and then run a loop which is timed to drop us off at a safe point in HBlank at the ~end~ of the scanline, then quickly set the 4 registers and return. This wastes almost an entire scanline waiting for each raster table entry!
		Why would we do such a thing?! The scanline interrupt can even be programmed to fire when HBlank starts, why not use that? The problem there is once our interrupt handler has control it has to push registers to the stack to protect their contents, check if we're at the LY line we're interested in, point to the correct raster table entry, and finally set the 4 registers. There simply isn't enough time to do all that in HBlank (active sprites cut into HBlank time, and we occasionally have quite a few of them).
		This setup is used for almost all the effects in Shock Lobster, by dynamically changing the contents of the raster table as needed. Note that the raster table doesn't include the vertical scroll register, SCY. There were a few effects I wanted to include using SCY, but I couldn't fit the write into the interrupt handler, and instead did what I could with SCX/WX/LCDC.

		## Title Screen
		{^img games/shock_lobster/title_color.png}
		The titlescreen uses a classic horizontal scroll effect with two lookup tables generated at different frequencies and amplitudes to add an extra wobble feeling, meant to evoke a sense of being underwater.
		I expected to have to come up with something clever to render the seaweed, but to my surprise when using the 8x16 sprite mode I could stack 9 sprites vertically 4 times to span the full height of the screen, using only 36 of the 40 total hardware sprites.
		I tried to come up with tiles that would look good enough when wobbling back and forth without having to worry about their relative position, and I think the effect works out well in the end.
		To try to make things a little less deterministic the initial position of the seaweed columns is randomized. The columns of sprites also alternate priority bits an an attempt to make them appear to surround the logo.

		## Status Screen
		This screen may appear simple, and it's not exactly complicated, but it tries to pack the skill row, upgrade row, and item/options row into a screen along with some fairly lengthy detail text.

		### Overall Structure
		{^img games/shock_lobster/status_color1.png}
		The main icon panel is on the background layer, with the top bar and details screen drawn using the window. This allows me to keep the current pearl count visible at the top while scrolling the rows up and down to show the current row when the details panel is expanded.
		To smooth movement on this panel out a bit, all cursor and panel movements move half the distance to their target location per frame, which gives a slight decelleration to the movements.
		Note that even though both the background and window are used, they share a single tilemap. In order to pull this off using only the background I'd need to have SCY as an entry in the raster table, so that I could dynamically adjust it at several points during the frame. By using the window I can set the window vertical position (WY) outside the interupt handler, and then toggle the window on/off as required throughout the frame.
		{^img games/shock_lobster/status_tilemap.png}
		I discovered while working on this game that turning off the window mid-frame via the LCDC register but keeping WX such that it lines up with SCX in certain ways would push an extra color 0 pixel out the PPU. To avoid this quirk, whenever I disable the window I also set WX to a value greater than 166. This was discovered late in development, and since I could effectively disable the window only with WX, the ~only~ thing the LCDC entry in the raster table is truly needed for is drawing the wide laser (see below).

		### Fitting All the Text
		To fit the text I searched all over for a font tiny enough to pack in all the text that also had a little flair to it. {https://mounirtohami.itch.io/minimalpixel-font MinimalPixel} by Mounir Tohami fit the bill! To render the variable-width font (VWF) in the game, I used the excellent {https://github.com/ISSOtm/gb-vwf gb-vwf} library by ISSOtm.
		One issue I ran into with VWF was rendering the longer skill descriptions would take several frames, which would block menu inputs and make the screen feel unresponsive. My solution was to set an optional "yield line", and if the VWF renderer was past that line after rendering a character it would set a 1 frame delay and continue from that point on the subsequent frame.
		{^img games/shock_lobster/status_color2.png}
		An interesting side-effect of that addition was that sometimes the VBlank handler (called as a result of the VBlank interrupt at line 144) would finish in fewer than 10 lines (the duration of VBlank), especially when music was disabled, and the text engine would yield immediately, since the current line would be >144. The fix for that issue ended up being amusingly simple: I call `halt` in the main loop once, which waits until the next interrupt, and since the raster lookup is configured to disable the window layer on line 8 (after the first row of tiles is shown), text rendering starts just after that handler returns, having wasted very little time and ensuring the yield is never falsely triggered!
		{^img games/shock_lobster/status_color3.png}
		As it stands all the text ends up filling tile VRAM near to the breaking point! The first block of tiles (used only for sprites in Shock Lobster) has quite a bit of space to spare. If I'd needed to squeeze more text on this screen I could have expanded into the first block and used a mid-screen LCDC write to switch blocks, but luckily that wasn't necessary.
		{^img games/shock_lobster/status_tiles.png}

		### Getting Players to Press Select
		The hardest game design component of this screen to get right is getting players to press `Select` to expand out the details panel, which contains some very important gameplay details. In the end I settled on bouncing in an indicator if the player's high score was less than 1000, or they hadn't yet pressed Select during this power cycle. People still fail to realize they can expand the details panel all the time, and I'm not sure how to improve it. I'd considered starting this screen with the panel visible, but felt it hid the multiple rows of items in a manner that was even more confusing.

		# Gameplay

		## Drawing the Large Enemy
		On any modern playform drawing a "large" (32x32) enemy wouldn't be remotely noteworthy. Depending on circumstances it can be a bit of a challenge on the Game Boy. There are two limitations which can present problems: A maximum of 40 sprites can be used at once, and only 10 sprites can be visible on a scanline at a time. In this case only the later presents a problem.
		{^img games/shock_lobster/gameplay_color1.png}
		I knew I wanted to have damage numbers popping out of the enemy, plus have the player sprite on the same line, and obstacles scrolling across the screen. Between the player and two obstacles we're already at 6 sprites per line (each is 16x16, requiring 2 sprites in 8x16 sprite mode), and with damage numbers generally taking 2 sprites we'd hit the 10 sprite/line limit quite often.
		So, how do we include an additional 32x32 enemy on the same line? A common trick in older games is to use the entire background layer to draw a large boss enemy, with the background entirely blank. I wanted to use the actual background to show scrolling terrain and collectable pearls, so I looked to the often maligned window "layer".
		I put layer in quotes because people often expect the window to be capable of transparency or other fancy tricks. The truth is it's quite limited and really just an alternate background tilemap (or the same tilemap positioned differently) which the PPU can draw from starting at a given horizontal position, and continuing to the right edge of the screen. As long as the enemy stays touching (or off) the right side of the screen, and mostly fills the space it occupies, the effect can be reasonably convincing.
		{^img games/shock_lobster/gameplay_1.png}
		Moving the enemy around is accomplished by making adjustments to the raster lookup table. One quirk of the window is the current tilemap position when drawing the window only advances when the window is enabled on the current scanline ~and~ at least one column of pixels is on-screen. When the enemy is defeated a single line of it is left visible when loading the new enemy, or the lower portion of the screen would look like a total mess during the transition. This specific window quirk is the main reason Shock Lobster has problems running on less accurate emulators, as very few games seem to depend on it so developers can easily get away without capturing it correctly.
		Luckily the tiles for an entire enemy can be copied safely within a single frame when spawning without having to be clever. This image from {https://emulicious.net/ Emulicious'} event viewer shows the STAT checks (green) for VRAM access, as well as the VRAM writes (purple) to perform the full tile copy. The yellow region on the left is the OAM scan mode, the light green region on the right is HBlank, and the cyan region on the bottom is VBlank.
		{^img games/shock_lobster/vram_copy.png}

		## Drawing a Wide Laser
		So we've got the player, obstacles, damage numbers maxing out the sprite limit per line, and a large enemy drawn with the window. Now we want to draw a ~wide~ laser across the screen when attacks are used. How can we accomplish that?
		My solution was to fill the second tilemap with a bunch of dark grey tiles in the space between the player and the enemy, and set the raster table to swap the background between the two tilemaps for a few scanlines, then back again. The horizontal scroll register is also adjusted to give the laser a sense of movement, with each attack using a slightly different width and scroll combination (the difference is pretty subtle).
		{^img games/shock_lobster/gameplay_color2.png}
		If you look closely you can see the area to the left of the player has a thin white line when the laser is visible, but given how light the background terrain is this is generally not very obvious (especially on actual hardware).

		## Changing the Scrolling Terrain
		Years ago I recalled hearing about how Super Mario Bros used the same tiles for both the bushes and the clouds. Inspired by this I drew a single continuous background image which I hoped would tell the story of movement from the depths of the sea to an area above the clouds, reusing portions of the tiles to represent different terrain.
		{^img games/shock_lobster/terrain.png}
		The tilemap representing the background is uncompressed to WRAM on startup, and when a new enemy is spawned a pointer is adjusted to indicate the top row of the tilemap to pull from when streaming in new terrain from the right. The transition can be a little rough, but it's generally over pretty quickly and the player is too busy playing the game to worry about how seamless the background is.

		## Smoothly Scrolling Timer Bars
		After all the other hoops we've jumped through these bars end up being a pretty straightforward affair. These bars could have been rendered as the enemy health and energy bars were, using a set of static tiles, but in order to texture the tiles we will once again depend on the raster table!
		The action button panel on the right is drawn using the window, so the background can be scrolled as needed to show the appropriate bar position. Each skill uses a distinct lookup table to scroll its bar as needed given they have different maximum durations. In addition, the "focus" skill can show both the 4 second skill duration and the lengthy cooldown duration. To accomplish this, a second bar is present on the background tilemap, with scroll values to match.
		{^img games/shock_lobster/gameplay_2.png}
		The image above shows the tilemap containing the bars, with vertical lines indicating the region visible due to the horizontal scroll setting at that scanline. The following image shows the end result on-screen for the same state.
		{^img games/shock_lobster/gameplay_3.png}

		## Eight Quick Actions with Only Two Action Buttons
		From the start I knew I wanted to have a fairly large number of actions available to the player at any one time without requiring them to navigate a menu. My solution was four pairs of actions, selectable using the D-pad, with A and B used to activate either action in the current pair.
		{^img games/shock_lobster/action_buttons.png}
		Initially there was no jump/jet action, but without a way to fail the game didn't seem to have much point. I looked around for games based around a single button, and Flappy Bird was a pretty obvious source for inspiration. One action was sacrificed to add the jump action, and obstacles were added to give the player a way to fail.
		Given how challenging the jumping aspect of the game can be, it may be surprising to learn that it wasn't part of the original concept!

		## Variable Speed Gameplay
		In order to ramp up the difficulty, the game starts at a fairly slow pace and gradually speeds up. To ensure the physics of the collisions remained reliable this is accomplished by using a fixed point "physics delta". Each frame the delta is applied and a number of physics updates equal to the integer portion of the fixed point value are performed.
		The delta is increased at different intervals based on the selected game speed. The three speed settings were tuned around an intended game session duration for the "2" setting, and then slower/faster rates for the other two settings.

		# Keeping Things Small
		The Game Boy can only access up to 32 KiB of ROM at a time. Early games were often only 32 KiB, with later games using memory bank controllers (MBCs), which generally keep the first 16 KiB in place (ROM0), and change the bank the second 16 KiB points to (ROMX).
		As a personal challenge, I chose to limit Shock Lobster to 32 KiB, which would allow it to be used on a wider range of flashcarts. Code tends to not expand too quickly, though it still helps to avoid being wasteful. Assets (graphics, music, levels, text) are where space is often quickly eaten up. To fit the game a variety of techniques were employed.
		At this point (version 1.3), {https://github.com/bbbbbr/romusage romusage} by bbbbbr reports 100 bytes free between ROM0 and ROM_0. The initial release was packed even tighter but I've found some space savings since then.
		> Bank           Range             Size   Used   Used%   Free  Free%
		> ----------     ----------------  -----  -----  -----  -----  -----
		> ROM            0x0000 -> 0x3FFF  16384  16327   99%      57     0% |############################|
		> ROM_0          0x4000 -> 0x7FFF  16384  16341   99%      43     0% |###########################-|
		> VRAM_0         0x8000 -> 0x9FFF   8192   5152   62%    3040    37% |###-...##############.......|
		> XRAM_0         0xA000 -> 0xBFFF   8192     56    0%    8136    99% |............................|
		> WRAM           0xC000 -> 0xCFFF   4096   3182   77%     914    22% |#################-#---......|
		> WRAM_1_0       0xD000 -> 0xDFFF   4096   1216   29%    2880    70% |-.--#####-.................-|
		> HRAM           0xFF80 -> 0xFFFE    127     46   36%      81    63% |###########-................|
		## PB16 Compression
		PinoBatch's PB16 compression was used to compress:
		+ Dimmed skill icon tiles
		+ Options icon tiles
		+ The background graphics and tilemap
		+ The enemy tiles
		+ Title screen tiles
		## VWF Dictionary
		The skill/upgrade descriptions contain a lot of redundant text, and text takes up a ~lot~ of space. The previous sentence would take 99 bytes if stored raw, more than the space required for 6 uncompressed 8x8 tiles!
		To fit all the descriptions in I added a dictionary feature to the VWF library, allowing me to store certain strings only once and then refer to them via indicies. There are likely even more efficient approaches, but this method worked well enough for my purposes.
		## Obstacle Animation Paths
		The obstacle animations paths are stored as a series of deltaX/deltaY pairs, applied at each physics timestep. By tweaking the paths used to generate the data I was able to limit each delta to a range of -1 (0xff) to 2 (0x02), which takes only 2 bits per value to store. This allows two deltaX/deltaY pairs to be stored in a single byte, cutting the ROM space requirement down by 4 (compared to how they're stored in WRAM once unpacked).
		## Pearl Patterns
		Each vertical strip of pearls is stored as bits in a single byte, allowing for up to 8 pearls per column, and keeping their memory footprint fairly small. This could be further reduced by mirroring patterns at runtime instead of storing both variations (where applicable).
		The pearl patterns are generated by a script which parses PNG files made up of a leading row which defines the 0/1 color values, and then 8 rows of an arbitrary length. This allows new patterns to be quickly created in any image editor and automatically fed into the game.
		## Music
		Luckily I had placeholder music in the game for most of the development, because with days remaining before the competition deadline I found out that music data can take a ~lot~ more ROM space than I'd anticipated.
		Fitting in short tunes for the game over and high score states still required trimming them down to be quite short and hand-editing music pattern tables to reuse a shared "empty" pattern.
		In the future I'd like to look into compressing music data in ROM, as I ended up with quite a bit of spare WRAM and suspect I could free up 1-2 KiB of ROM by compressing the current music.

	LINKS
		itch : https://tbsp.itch.io/shock-lobster
		source : https://github.com/tbsp/shock-lobster
		competition : https://itch.io/jam/gbcompo21

FRUIT PURSUIT
	HOST : interactive
	BREF : A match 3 game for Game Boy
	BODY
		{^img games/fruit_pursuit/title.png}
		# History
		In 2019 I fell into a Monster Hunter 4 Ultimate hole for a while. I kicked the idea for what kind of Monster Hunter game on Game Boy might be practical (both for myself and the hardware). At some point I decided to try overlaying the meta game (farming materials, crafting) onto an entirely different genre.
		As the match-3 genre hadn't really emerged when the Game Boy was a current system, and homebrew games of that genre so far seemed to use a coarse background based drop animation, I thought I'd try my hand at a smooth dropping animation. After I got the animation working (more on that later), I set about adding the Monster Hunter metagame elements. I'd originally expected the game to take 2 years to make, but as time went on it became clear it'd be far longer.
		I let the project lapse for a while, tinkering with other ideas and working on Shock Lobster, but when early 2022 rolled around I decided it was a shame to let the work I'd put in go to waste, and set about stripping down the game, retheming it, and trying to get something playable out the door.
		# Overview
		Fruit Pursuit is a fairly simple match-3 game, where a timer bar is constantly draining, matches extend the bar, and you have to match a certain number of each fruit to clear a lap. There are a few mode which tweak the basics, but all work pretty similarly.
		{^img games/fruit_pursuit/gameplay_cgb.png}
		# The Hard Part
		In a match game, when items are cleared the remaining items (along with new ones, in this case) generally drop down. Existing match games for Game Boy which I could find ({https://github.com/AntonioND/geometrix Geometrix}, {https://furrtek.itch.io/airaki Airaki}, etc) animated the dropping by re-writing the background tilemap. While effective, it limits the per-frame movement to 8 pixel increments. My hope was to allow per-pixel smooth animation of the collapse.
		The approach I ended up settling on switches to a tilemap which only has the non-moving items present, and all dropping items are drawn using objects (sprites). The Game Boy only has memory for 40 hardware objects (sprites) at once. In addition, only 10 can be drawn per line. These limitations mean we can only animate dropping up to 5 columns (2 sprites per item) and 4 rows at once before we have to get creative.
		To work around the row limitation we use OAM DMA to copy the topmost 40 sprites, and then use a popslide to copy 4 bytes per scanline once we're far enough down the screen to not clobber the sprites we want to show. Note that since we're often at the 10 sprites/line limit HBlank is quite short, so a popslide is necessary to perform the copy quickly enough.
		To work around the column limitation we use "sprite flickering", which many are familiar from the NES, where it seems to be a more accepted practice. Clearing more than 5 columns at once is fairly uncommon, so this doesn't show up very often. Note that I also implemented a full row clearing animation, since at one stage I was planning to include items to clear entire rows. It used dynamic Y scroll register writes, followed by a transition to the approach described above.
		In addition, the drop animation is performed in two stages, so in cases where at first 6 columns are dropping, and then it changes to 5 or fewer, the flicker will only be present while 6 are actively dropping.
		Note that all the data tracking to advance the objects, determine when they've settled, and generate the OAM data takes quite a bit of time. Getting all that computation performed in time required breaking it into chunks. While waiting to start the manual OAM popslide we first quickly calculate the positions of the new OAM entries as well.
		# Refining Things
		{^img games/fruit_pursuit/gameplay_dmg.png}
		Although single pixel dropping looks really smooth, it ends up being pretty slow. Later in development a lookup table was added to approximate acceleration due to gravity, drastically speeding up the drop while still retaining a smooth feeling. The table is tweaked slightly from a clean curve to ensure items will always hit every 16 pixel boundary exactly, so I never have to check for overshoot.
		There's also a lot of background tilemap juggling involved to make the effect seamless. The final result looks quite simple, but watching a tilemap viewer in an emulator debugger reveals quite a bit more is going on than it may seem.
		I also managed to find a way to make the fruit tiles, which lean heavily on colour to distinguish each other, look reasonably distinct on the original Game Boy by adding various backdrop shades.
		# Conclusion
		In the end I'm very happy with where things ended up. I still have a huge list of things I'd like to polish on the game, but it's definitely playable, and I find it reasonably fun.
		Perhaps one day I'll feel compelled to return to the project and tidy up all the loose ends.

	LINKS
		itch : https://tbsp.itch.io/fruit-pursuit

UXNGB
	HOST : development
	BREF : A Uxn emulator for Game Boy
	BODY
		### Motivation
		Given the relative simplicity of Uxn/Varvara, and my knowledge of the GB/GBC architecture, trying to write a Uxn emulator for GB/GBC seemed like a natural fit.
		I went in knowing full well that several things were stacked against success:
		+ No bitmap rendering mode on GB
		+ Memory typically only addressed 8 KiB at a time (Uxn can address a full 64 KiB)
		+ No second graphical layer which can cover the entire screen with transparency (needed for fully functional foreground layer)
		+ Relatively slow CPU (with no native MUL/DIV instructions)
		Despite this I took a shot and am rather pleased with the final result.
		{^img games/uxngb/screen.png}
		### Room for improvement
		+ Use additional tile VRAM on GBC to expand foreground sprite support
		+ Use additional DMA features on GBC to speed up VRAM writes
		+ Use banked external cartridge RAM to support the full Uxn memory space
		{^img games/uxngb/pong.png}

	LINKS
		source : https://github.com/tbsp/uxngb
		uxn : https://wiki.xxiivv.com/site/uxn.html

VARVARAPSP
	HOST : development
	BREF : A Varvara VM for PlayStation Portable
	BODY
		Although the Uxn lines thread included a photo of Varvara running on a PSP (actually a Vita) quite early, there didn't appear to be a maintained implementation for PSP on the Awesome Uxn list.

		Out of curiosity for how well the PSP could run Oquonie (one of the more demanding Varvara ROMs), I took to porting the SDL reference emulator. Getting the basic port running tool very little time, in fact. Sadly the performance wasn't close to sufficient for playing Oquonie.

		Switching the screen, controller, and audio from SDL to native API calls was again not too hard, and provided a nice performance boost.

		The next step, using the "Gu" (think GPU), was quite a bit harder. In the end the code to make things work wasn't very far off the samples which come with the PSPDEV SDK, and I can no longer recall the things I had to tweak, but once everything fell into place I was much closer to my intended goal!

		A few more optimizations in terms of subdivided sprite draws, and using a lookup table based screen_blit from uxnGBA, and Oquonie was within reach of playable.

		Having exhausted ideas up to that point I asked on the PSPDEV discord for ideas and the (now) super obvious suggestion of enabling compiler optimizations was proposed. 

		Oops. That's what I get for so much time using assemblers instead of compilers.

		`-O2 -g0` added to the compiler flags and a huge surge in performance later my ultimate goal was reached: Oquonie playable at full speed on PSP! Fourtette could even manage full-speed smooth music during gameplay, which I had never expected. 

		Chances are many of the struggles were no longer necessary in the end, but learning some more tricks (and some gotchas of RISC processors) was a fun adventure at the time.

		Last edit: 2023-08-10

VARABOY
	HOST : development
	BREF : A Game Boy emulator for Uxn/Varvara
	BODY
		## Background 
		Although I've been writing software for Game Boy on and off since the late 90s, I've never undertaken a very common related task: writing a Game Boy emulator. For some reason the idea of doing so never seemed particularly appealing, given the available emulators/debuggers always more than fulfilled my needs, and I was more drawn to creating original software for the platform instead (though if I succeeded in that regard is another matter).
		For some reason that all changed when I was trying to come up with what I considered interesting projects to work on for Uxn, and thus Varaboy was born!
		## Challenges
		The Game Boy is an incredibly well-documented piece of hardware, with some insanely accurate emulators available. There are still quirks which aren't fully understood, and getting certain games running correctly can be quite tough, but if you just want to emulate the bulk of popular games to a playable degree there isn't too much involved. 
		Writing a Game Boy emulator for Uxn/Varvara presents a few somewhat unique challenges, mainly:
		+ Emulating a device with a 64KiB address space on a device with a 64KiB address space.
		+ Getting things to run at playable speeds.
		I don't mean to make either of these seem like particularly hard challenges, but for me they added just the right amount of resistance to make the project enjoyable.
		## Solutions
		### Address Space
		My solution to dealing with the matched address spaces was to take advantage of the ~8KiB echo RAM region on the Game Boy. Essentially as long as I could fit my emulator'a runtime code/data inside the "off-limits" echo RAM region I could leave addresses totally untouched from the Game Boy's perspective, which really helps performance (and simplicity).
		### Performance
		Performance was a big unknown when I started this project. I had no idea what to expect. It could have trivially hit 60fps with no effort, or never reached playable speeds on available hardware. The initial release could be considered barely playable on a fast CPU with a frameskip of 3. Luckily I quickly realized what a friend had tried to explain to me, which is that I was checking for visible sprites every pixel instead of once per line. Fixing that issue drastically sped up the PPU (pixel processing unit), allowing for 60fps on a fast CPU. 
		Shortly after fixing the OAM scan I realized that after every instruction I was advancing the PPU one dot at a time, which would meaning checking for PPU mode advancement 4-24 times per instruction, when nothing about my rendered depending on that precision. Switching to only checking for mode advancement once per instruction almost halved the runtime of the cpu_instrs test ROM, which was another huge boost. 
		## Future Work
		At this stage I'm mainly expecting minor performance gains by condensing the uxntal code. 
		Changing the active ROM bank on hardware is considered instantaneous, so some games bank swap quite often, but Varaboy has to read all preceding banks right now to load the new one. Unpacking banked ROMs on load should improve performance for such games, at the cost of cluttering up the directory.
		The MBC code could be cleaned up to support larger games as well. 
		The big missing feature at this stage is sound support. There's about 1KiB of spare echo RAM available right now, which feels like it probably isn't enough for even basic audio support. Having said that I might take a shot at it to see if it can be made at least passable. 
		### uxngb in Varaboy
		Although it's totally impractical, it's entirely possible to run Uxn ROMs under 8KiB inside uxngb, emulated inside Varaboy in another Uxn VM. Sadly the opposite isn't currently possible due to uxngb's 8KiB limit.
		I'm tempted to make a fork of uxngb which adds full 64KiB support just to get that working, because it'd be pretty amusing. 
		## Conclusion
		I've ended up putting more time into Varaboy than I expected to, but also ended up with a far more functional emulator than anticipated. The feeling of getting games I'd played so many times running in something I'd written myself was far more fulfilling than I expected and I'm very glad I took a shot at it.

	LINKS
		source : https://github.com/tbsp/varaboy
		Uxn : https://wiki.xxiivv.com/site/uxn.html

TAKALAKI
	HOST : development
	BREF : Takalaki - A personal virtual machine using the Uxn CPU
	BODY
		## Status
		An initial implementation of two scrollable tile layers, a window, and a raster vector can be found in the {https://codeberg.org/tbsp/takalaki Takalaki Codeberg repo}. The raster.tal example gives a very simple example of use.

		## Overview
		Takalaki is a Varvara clone with an additional raster device which builds upon the screen device, with the goal of streamlining development of tile-based games. It's fully backwards compatible with Varvara, with the raster device residing in the `0xe0` device range.
		The two existing bitmap layers (fg and bg) are rendered interlaced with the two new tile layers. All four layers can be toggled independently, as well as have their visibility controlled using a window with adjustable edges. Along with all this is a new vector, which is evaluated before rendering every scanline, allowing for a variety of raster effects.
		This combination ends up giving something more powerful than a GBA in some ways (simultaneous tiled/bitmap layers), but less powerful in others (only a single four-color palette).
		Both the tile layers can either wrap or crop [planned] at the tilemap edges, and can use Varvara-style blend modes. Each tile layer can be set to have a map with width and height of 16, 32, 64, or 128, and pulls from up to 256 tiles. Each tile layer can optionally be provided with a map of attribute data, allowing per-tile flips, priority, and blending [planned].
		The window is a rectangular region defined by left/right/top/bottom values. The `winctrl` port specifies which of the aforementioned layers (tile0, tile1, fg, bg) will be drawn either inside or outside the window (when enabled). By making use of the raster vector complex window shapes can be created.
		My hope is to first implement the screen extensions based on the reference uxnemu emulator, and later develop my own original emulator with extended debugging tools.

HISTORY
	HOST : takalaki
	BREF : History of the Takalaki virtual machine
	BODY
		## Takalaki History
		Varvara, the first graphical system built around the Uxn CPU strikes a fantastic balanace of simplicity and power in an incredibly lightweight implementation, allowing for some surprisingly powerful tools to be created in very little space.
		I've found writing uxntal (the Uxn assembly language) to be a wonderful experience, but my years of working with tile based systems like the Game Boy have left me itching for a more familiar display device. In late 2022 I spent a bunch of time thinking about an alternate display device for Varvara based around tiles and tilemaps, allowing for easy scrolling and even raster effects. At the time my focus was ease of implementation of a VM hosted by the Game Boy (or possibly the NES/SMS/GG).
		After a while I came to terms with the fact that uxntal on GB would likely never be particularly fast, even if I made the display as close to native as possible, and I'd probably resort to writing native GB assembly once I hit the performance ceiling. After some time away I was reminded of Devine Lu Linvega's hopes that Uxn would inspire people to create their own personal computing platform, and Takalaki was born.
		The initial Takalaki design had a collapsed device port layout, a controller with 3 action buttons (instead of 2), simplified audio devices, and an expanded display device limited to a maximum resolution of 256x256.
		After a while working on refining the design and starting on the implementation I decided to abandon most of the refinements I'd come up with, and retool Takalaki as a fully backwards compatible Varvara clone with an extended screen device. This felt like it would allow me to stay close enough to the evolving Uxn ecosystem while still exploring the tile-based space as desired.

RASTER DEVICE
	HOST : takalaki
	BREF : A Uxn raster device that builds on top of the Varvara screen device
	BODY
		## Disclaimer
		This device is very much in flux, and will change as I tinker with it. Assume it will change, possible dramatically.
		## Raster Device Ports
		| *port*| *register*| *use*|
		| 00| vector*| raster vector|
		| 02| dispctrl| control visible layers|
		| 03| winctrl| control layers inside/outside window bounds|
		| 04| position| set tile layer scrolls and window bounds|
		| 05| mapconfig| configure the tile layer maps|
		| 06| tileconfig| configure the tile layer tiles|
		| 07| blit| operation to blit to the bitmap layer [planned]|
		| 08| polygon| operation to draw a polygon to the bitmap layer [planned]|
		| 0e| scanline*| current scanline during raster vector|
		### vector
		The raster vector is evaluated at the start of every scanline if the address is set. The scanline port can be read to determine the current scanline inside the raster vector handler. During the raster vector any changes to dispctrl, winctrl, position, mapconfig, tileconfig, or the system palette will take effect from that scanline forward.
		### dispctrl
		Controls which layers are visible. By default layers are drawn front-to-back in the order: fg > tile1 > bg > tile0. The drawing order can be adjusted by setting the tile priority bit (see `tileconfig`). By default only the fg and bg layers are enabled, for Varvara backwards compatibility. Note that when only fg/bg layers are enabled the first color of the fg layer is transparent to maintain compatibility with Varvara software.
		> x x x W   F B 1 0<br>| | | |   | | | +-- tile0 enable<br>| | | |   | | +---- tile1 enable<br>| | | |   | +------ bg enable<br>| | | |   +-------- fg enable<br>| | | +------------ window enable<br>| | +-------------- unused<br>| +---------------- unused<br>+------------------ unused
		### winctrl
		When the window is active the `winctrl` port specifies which layers (assuming they're enabled in `dispctrl`) will be shown both inside (low nibble) and outside (high nibble) the window bounds. The bounds default from (0, 0) to (1024, 1024), and can be set using the `position` port.
		> F B 1 0   F B 1 0<br>| | | |   | | | +-- tile0 inside<br>| | | |   | | +---- tile1 inside<br>| | | |   | +------ bg inside<br>| | | |   +-------- fg inside<br>| | | +------------ tile0 outside<br>| | +-------------- tile1 outside<br>| +---------------- bg outside<br>+------------------ fg outside
		### mapconfig
		The `mapconfig` port is used to configure the map settings for each tile layer.
		> H H W W   A C R T<br>| | | |   | | | +-- tile layer select<br>| | | |   | | +---- set map addr<br>| | | |   | +------ enable crop [planned]<br>| | | |   +-------- enable attribute map [planned]<br>| | +-+------------ map width (16, 32, 64, 128 tiles)<br>+-+---------------- map height (16, 32, 64, 128 tiles)
		### tileconfig
		The `tileconfig` port is used to configure the tiles for each tile layer. If the priority bit is set, the tile layer will be drawn infront of it's neighbouring bitmap layer. That is, tile0 with priority will be drawn infront of bg, and tile1 with priority will be drawn infront of fg.
		> B B B B   P D R T<br>| | | |   | | | +-- tile layer select<br>| | | |   | | +---- set tiles addr<br>| | | |   | +------ select tile depth (1bpp/2bpp)<br>| | | |   +-------- priority<br>+-+-+-+------------ blend mode
		### position
		The `position` port is used to transfer the screen x/y values to the tile layer scroll registers and the window edge registers. The value set indicates which scroll registers should be set, with multiple sets being settable at once if the x/y coordinates are the same.
		> R L B T   Y1 X1 Y0 X0<br>| | | |    |  |  |  +-- tile0 scroll x<br>| | | |    |  |  +----- tile0 scroll y<br>| | | |    |  +-------- tile1 scroll x<br>| | | |    +----------- tile1 scroll y<br>| | | +---------------- window top edge<br>| | +------------------ window bottom edge<br>| +-------------------- window left edge<br>+---------------------- window right edge
		### Blit [planned]
		A blitter may be added if I can settle on a style I'm comfortable with.
		### Polygon [planned]
		Heavily inspired by the {https://blazebone.com/pochi/devices.html#poly Pochi poly port}, the polygon port draws a filled or hollow polygon. A hollow polygon may also be unclosed.
		To draw a polygon, set `addr` to point to an address which specifies the number of corners in the polygon, followed by that many shorts defining the corner coordinates, with the first byte containing the X coordinate, and the second byte containing the Y coordinate. All coordinates are relative to (0,0) at the top left corner of the display.
		Note: The details of the byte written to `polygon` are TBD.

TAKARE
	HOST : development
	BREF : A low-spec tile-based VM based on the Uxn CPU
	BODY
		# Overview
		While the Varvara VM provides an excellent basis for high-resolution tools and games, the fairly restrained specifications are too ambitious for some older systems to support fully. To address this, Takare defines an even more limited specification focused on tile-based systems with hardware sprite support and simple tone/noise audio hardware.
		In addition, the target host systems often have in the range of 2-8KB of RAM, meaning the Uxn addressable memory is quite limited. To deal with this, the tile/tilemap copy routines and music driver are able to access data directly from ROM, leaving the Uxn addressable memory available for code and working data.
		# Uxn System
		While the Uxn CPU can address 64KB of RAM, Takare hosts may limit that to a much smaller range (as little as 1.5KB). The working and return stacks are reduced to only 32 bytes each, and the device ports are condensed into 64 bytes (as opposed to the 16 ports per device in Varvara).
		# Display
		The display is limited to 256x256 pixels. Two sets of 256 8x8 tiles (2bpp) are available. On some systems the tiles are fixed (NES CHR ROM), while others support dynamic tile loading from ROM (Game Boy). A single scrollable tile background layer is available, using a 32x32 tilemap and the first set of tiles. A number of 8x8 sprites are available (40-64, depending on the host), with per-line limits depending on the host (8-10).
		# Controller
		The controller is identical to Varvara, containing a 4-direction dpad, start/select, and A/B buttons.
		# Sound
		There are two tone channels, and a noise channel. A simple music driver is included in the VM host, allowing playback from music data stored in ROM.
		# Implementations
		An {https://codeberg.org/tbsp/takare-nes early NES implementation} has been created, which only supports basic sprites, and is limited to only 1024 bytes of Uxn RAM (plus the zero page). An alternate "tile" display device for {https://github.com/tbsp/uxngb/tree/master/src/emu_tile uxngb} has also been created in a similar style. It supports some of the background tilemap writing, as well as dynamic tile data.

META
	HOST : about
	BREF : About this website.
	BODY
		*wastingmoves.com* is the personal website, digital garden, and {projects project archive} of {personal Dave VanEe}.
		It was inspired by similar sites scattered across the world wide web (and elsewhere), perhaps driven by nostalgia of a "simpler time" on the internet.
		Although in time I may spin up my own static site generator, for now I'm using a fork of Clemens Scott's {https://git.sr.ht/~rostiger/nchrs/ Nchrs} code, which was forked from Devine Lu Linvega's {https://github.com/XXIIVV/oscean Oscean} (prior to the transition to {https://wiki.xxiivv.com/site/uxn.html Uxn}). I've tweaked the link formatting, switched to a dark theme, and added a custom markdown entry to increase Persian font sizes for readability. Originally I looked into forking Oscean in the current state, but had some issues getting everything working as I wanted.
		WastingMoves is made up of static HTML pages generated by a single-file C program, using human-readable plaintext database files using the ~Tablatal~ and ~Indental~ formats. The sitemap can be found on the {404} page. There's no JavaScript or external content. Many thanks to Clemens Scott for the automatic image processing code, which dramatically reduces the bandwidth load of viewing the website.
		The website icon was drawn in {https://hundredrabbits.itch.io/dotgrid Dotgrid}, followed by hand edits to the resulting SVG file.

		### Dependencies
		To build the website, a bash script called `build.sh` needs to be executed. It compiles `main.c`, runs the executable that outputs the content of `databases/lexicon.ndtl` and `databases/glossary.ndtl` to single HTML files and finally removes the executable again. `clang-format` formats the code before compilation.
		WastingMoves supports responsive images and lazyloading to preserve bandwidth. The original images are stored in `src/media/` and are converted to appropriate sizes and dithered by the `batchVariants` bash script using imagemagick. Note that this script must be run before `build.sh` for the media directory to be populated.
		GIFs are converted the MP4 using `ffmpeg` within the `makeVideo` script.
		All of the above scripts are executed when the `deploy.sh` is called. The whole repository (including build artifacts) is then committed to Github, where it's hosted as a Github pages site.
	LINKS
		source files : https://github.com/tbsp/wastingmoves/
		NChrs : https://nchrs.xyz/
		XXIIVV : https://wiki.xxiivv.com/site/about.html

LICENSE
	HOST : meta
	BREF : License.
	BODY
		The assets and text content is under the BY-NC-SA4.0 License.
		~You are free to:~<br />*Share:* copy and redistribute the material in any medium or format.<br />*Adapt:* remix, transform, and build upon the material.
		~Under the following terms:~<br />*Attribution:* You must give appropriate credit.<br />*NonCommercial:* You may not use the material for commercial purposes.<br />*ShareAlike:* You must distribute your contributions under the same license.
	LINKS
		BY-NC-SA4.0 License : https://creativecommons.org/licenses/by-nc-sa/4.0/

MARKDOWN
	HOST : meta
	BREF : WastingMoves supports a unique flavor of markdown format.
	BODY
		### Headings
		```
		# Heading 1
		## Heading 2
		### Heading 3
		#### Heading 4 
		```
		### Text
		```
		This is a paragraph.<br />Line breaks need a < br > HTML tag.
		This text is *bold*.
		This text is ~italic~.
		This text is ^larger^.
		```
		### Lists
		```
		+ List Item 1
		+ List Item 2
		+ List Item 3
		```
		### Quotes
		```
		"This a quote."
		- This is a cite.
		```
		### Tables
		```
		| Column 1 | Column 2 | Column 3 |
		| Column 1 | Column 2 | Column 3 |
		```
		### Code
		```
		`This is code.`
		> This is a code block.
		```
		Use two `` before and after a multiline text block to create a markdown formated code block.
		Use three ``` before and after a multiline text block to create a code block that ignores markdown.

PERSONAL
	HOST : about
	BREF : Who am I?
	BODY
		My name is Dave VanEe and I live with my partner and our daughter in Vancouver, Canada.
		I go by *tbsp* online, which was chosen as a semi-random sequence of letters I liked the look of, but also stands for "tablespoon" out of pure coincidence.
		I am an employee of a local aerospace engineering consulting firm where I work as an engineer and software developer.

INVENTORY
	HOST : directory
	TYPE : img_portal
	BREF : Recurring items.
	BODY

TOOLS
	HOST : inventory
	BREF : Utilities for work and play.
	TYPE : full_portal
	BODY

STORMRAGE
	HOST : tools
	BREF : The daily driver.
	BODY
		This computer is my daily driver for projects and communication. It runs Windows 10 alongside a selected range of {software}. I've considered moving to a low-power (possibly RaspPi4 based) daily driver, but an unexpected hardware failure in the middle of a project prompted a quick replacement.
		{^list stormrage specs}

SOFTWARE
	HOST : tools
	BREF : Utilities to get things done.
	BODY
		### Utilities
		+ Firefox - world wide web browser
		+ SpeedCrunch - calculator
		### Communication
		+ Quassel IRC - IRC client
		### Image Editing
		+ LibreSprite - pixel graphics editor
		+ Inkscape - vector graphics editor

EVERYDAY
	HOST : inventory
	BREF : Everyday objects.
	TYPE : img_portal
	BODY

BIKE
	HOST : everyday
	BREF : 2009 Specialized Tricross
	TYPE : text_portal 
	BODY
		This bike was fully funded by trading in my 1986 Pontiac Grand Am for BC's Scrap-It program in 2009. It was was my primary means of transportation for 10 years. I started working from home in March 2020 due to the pandemic and my cycling dropped off immediately. I hope to one day return to the office and resume regular cycling.

PHONE
	HOST : everyday
	BREF : Google Pixel 3
	BODY
		## Phone History
		I've never had a personal land line. I had the choice between a cellphone and a landline when I went to university, and the cost was about the same at the time, so a cellphone seemed like a given. It feels strange to me that so many forms still have spaces for "home" and "cell" numbers. The very first phone I bought had no clock, so I exchanged it after a week for one which did. Both the clerk and my father acted like I was crazy for wanting a clock on my phone, "That's what a watch is for!".
		I used the same Sanyo phone from 1999 to 2004 followed by a flip phone from 2004 to 2010. Eventually I stopped getting calls/text and my provider said it might be because my phone was too old. I doubt that was really the problem. At that point I entered the land of Apple and used an iPhone 4, followed by an iPhone 5s. Having heard several positive reviews about Android devices I jumped to a Google Pixel 3 in 2018.
		## The Due App
		The one thing I didn't expect to be a problem was the fact that I had seemingly built a huge portion of my life around an iPhone exclusive app called "Due". The notifications on this app are just the right balance of persistent for me, vibrating every minute until you either snooze or dismiss them. I tend to forget things quickly, and having this app to keep things like bill payments, appointments, and simple errands from drifting into the background was something I found incredibly useful.
		I've tried something in the range of 10-20 similar apps for Android. Nothing is quite the same. Either new items are far too complicated to add, you have to go into the app to dismiss/snooze the items (instead of doing it directly from the lock screen), the notifications are ~too~ persistent (buzzing nonstop until you address them), or flaws in how the notifications are processed mean they eventually lose their hook and stop triggering.
		I've found threads on the internet with others similarly floundering for an Android-based alternative, but none of the solutions proposed worked for me. For now I've settled on TickTick, but it suffers from notifications occasionally failing to fire, likely due to some battery optimization system in Android suppressing them (no matter how often I try to fix that).
		### Moving On
		At this point I've essentially learned to live without the Due app. It's likely healthier anyways. What fascinates me so much is how unaware I was that the app had become such a key component of my day-to-day functioning, how insufficient Android-based alternatives were, and how long it'd take me to accept it and move on.
		## The Future
		Although I don't think I'm ready to abandon "smart" phones entirely, I definitely do not need a flagship device. Now with a child, having a decent camera on hand which automatically syncs photos to the cloud is something I don't think I'm willing to give up. I'm keeping my eyes on the low-end Android market moving forward, for when this phone eventually ceases to function, but concened the camera won't be quite up to the task.

READER
	HOST : everyday
	BREF : Barnes & Noble Nook Simple Touch
	BODY
		Prior to this device I had a 5" Sony e-ink reader for which I paid the staggering price of ~$500. Mere months after that purchase the market shifted and prices dropped quickly to the $250, and then $100 point. Although my 5" reader was functioning fine, the 6" screen called to me and at the relatively low price I snagged one on a trip to Seattle in 2011.
		Since then there has been little innovation in the space. Backlights have been added, but I find an overhead light more comfortable. Screens are slightly higher resolution, but not enough to justify a new device. I hope to keep using this device for many, many years to come!
	LINKS

INSTRUMENTS
	HOST : inventory
	BREF : Analog audio.
	BODY
		For most of my life I've longed to attain a level of mastery over one (or several) musical instruments. Sadly this has yet to occur, but that hasn't stopped me from collecting a variety of them in hopes of one day having one click. These are listed roughly in order of when they were obtained.
		### Zelda themed ocarina
		Purchased from a market in Salzburg, Austria. The sound of Zelda music being played on an ocarina in front of an old church on a cobblestone market square was magical.
		### 4-hole ocarina
		### Yamaha YP-50 Digital Piano
		I took piano lessons for a few months as a child and found it uninteresting. As I suspect is common I now wish I'd stuck with it. I've tried a few times to self-teach myself piano as an adult, lasting as long as several months at a time, but never retaining any real ability.
		### Mahalo Ukulele
		I know perhaps 15 chords and a few strumming patterns. Just enough to seem like I know what I'm doing to someone that doesn't know what I'm doing.
		### Strumstick
		I love the banjo-like sound of this instrument. It's very fun to strum or pluck away and explore simple tunes with this very light intrument.
		### CODE EDC
		When searching for interesting ocarinas I came across the Mountain Ocarina, which seemed very promising. Sadly it was no longer being produced and the creator was in the middle of a long journey designing a new instrument. Years later the CODA EDC (every day carry) was revealed! A quirky item but ~very~ easy to play.
		### Nuvo Recorder+
		After not getting too far with the CODA EDC I thought perhaps going for a more traditional instrument might be worth trying. Nuvo has a line of instruments targetting children, meant to simplify fingering. What surprised me immediately was how much more sensitive the recorder+ is to airflow than the CODA EDC, making the CODA suddenly more appealing due to the simplicity of producing clean notes, as well as accessing the second octave.

TABLETOP
	HOST : inventory
	BREF : A collection of board and card games.
	BODY
		I've amassed an uncomfortably large collection of board/card games. For several years a group of friends and I were playing board games multiple times a week, which seemed to justify the collection.
		We're very much at capacity for storing such items, and once our child is old enough to express interest in such games we'll likely have to downsize both to reduce clutter and to make room for more suitable games to play with the whole family.
		{^list tabletop}

READING
	HOST : directory
	BREF : The Library.
	BODY
		{^list reading list 2023}
		{^list childrens books}
		{^list reading list unfinished}

WATCHING
	HOST : directory
	BREF : The Cinema.
	BODY
		{^list watchlist 2023}
		{^list watchlist 2022}
		{^list watchlist 2021}

PLAYING
	HOST : directory
	BREF : Vidyagames.
	BODY
		This is a list of digital games. For analog games, see {tabletop}.
		{^list recently played}
		{^list playlist}

NOW
	HOST : personal
	BREF : What I'm currently working on.
	BODY
		+ Takalaki, a personal virtual machine based around the Uxn CPU

GOALS
	HOST : personal
	BREF : Looking forward.
	TYPE : text_portal
	BODY
		### Goals 2023
		+ Start meditation routine
		+ Start regular focused Persian practice
		### Long Term Goals
		+ Focus efforts on public welfare
		+ Decrease dependence on fossil fuels
		+ Create art and tools that contribute in positive ways

LANGUAGE
	HOST : knowledge
	BREF : Various notes on language.

PERSIAN
	HOST : language
	BREF : Notes on the Persian language.
	BODY
		## Font Sizes
		Much like {https://www.alexstrick.com/blog/why-are-arabic-fonts-so-small Arabic}, fonts for the Persian language on computers often end up appearing smaller relative to Latin alphabets for a given font size. To account for that, I've added a special markdown character `^` to locally increase the font size on this site when desired, intended for use with Persian script to make it more readable for myself. I'll likely tweak the relative size as I become more comfortable with reading the script, though my aging eyes will work against that.
		 
		vs
		^ ^

PROGRAMMING
	HOST : knowledge
	BREF : Collected notes on programming.
	TYPE : text_portal
	BODY

404
	HOST : index
	BREF : Halting
	BODY
		Your destination could not be found, please continue to the {index home portal} or choose a destination fromt the index below.
		An ~Orphan~ is an unlinked term, or a term that is not linked from any other term in the lexicon. A ~Deadend~ is a term that does not link to any other term in the lexicon. To learn more about how this page is automatically generated, see {meta}.

